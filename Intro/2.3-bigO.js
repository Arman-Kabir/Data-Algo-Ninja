// BIG O : Generalize the formal procedure of counting

// It allows us to talk formally about how the runtime of an algorithm grows as the inputs grow.
// We wont care about the details,only the trends.

// How the operations grow based on input ?
// * f(n) could be linear (f(n)=n)
// * f(n) could be quadratic  (f(n)=n2)
// * f(n) could be constant  (f(n)=0)
// * f(n) could be logarithmic  (f(n)=log n)
// * f(n) could be loglinear  (f(n)= n log(n))
// * f(n) could be something entirely different


// Normalizing and removing constant 
// O(500) - O(1)
// O(2n) - O(n)
// O(13n^2) - O(n^2)
// O(2n+2) - O(n)
// O(10n^2+n+2) - O(n)


